(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



xAct`xTerior`$xTensorVersionExpected={"1.1.0",{2013,9,1}};
xAct`xTerior`$Version={"0.8.5",{2013,7,1}};


(* xTerior: exterior calculus in Differential Geometry *)

(* Copyright (C) 2013 Alfonso Garcia-Parrado Gomez-Lobo and Leo C. Stein *)

(* This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License,or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place-Suite 330, Boston, MA 02111-1307, USA. 
*)


(* :Title: xTerior *)

(* :Author: Alfonso Garcia-Parrado Gomez-Lobo and Leo C. Stein *)

(* :Summary: exterior calculus in Differential Geometry *)

(* :Brief Discussion:
   - xTerior extends xAct to work with differentiable forms in general manifolds.
   - Introduces the exterior algebra, the exterior derivative, the Hodge dual, the connection and curvature forms for an arbitrary connection, the exterior covariant derivative.
   
*)
  
(* :Context: xAct`xTerior` *)

(* :Package Version: 0.8.5 *)

(* :Copyright: Alfonso Garcia-Parrado Gomez-Lobo and Leo C. Stein (2013) *)

(* :History: See xTerior.History *)

(* :Keywords: *)

(* :Source: xTerior.nb *)

(* :Warning: *)

(* :Mathematica Version: 9.0 and later *)

(* :Limitations:
	- ?? *)


With[{xAct`xTerior`Private`xTeriorSymbols=DeleteCases[Join[Names["xAct`xTerior`*"],Names["xAct`xTerior`Private`*"]],"$Version"|"xAct`xTerior`$Version"|"$xTensorVersionExpected"|"xAct`xTerior`$xTensorVersionExpected"]},
Unprotect/@xAct`xTerior`Private`xTeriorSymbols;
Clear/@xAct`xTerior`Private`xTeriorSymbols;
]


If[Unevaluated[xAct`xCore`Private`$LastPackage]===xAct`xCore`Private`$LastPackage,xAct`xCore`Private`$LastPackage="xAct`xTerior`"];


BeginPackage["xAct`xTerior`",{"xAct`xCoba`","xAct`xTensor`","xAct`xPerm`","xAct`xCore`"}]


If[Not@OrderedQ@Map[Last,{xAct`xTerior`$xTensorVersionExpected,xAct`xTensor`$Version}],Throw@Message[General::versions,"xTensor",xAct`xTensor`$Version,xAct`xTerior`$xTensorVersionExpected]]


Print[xAct`xCore`Private`bars]
Print["Package xAct`xTerior`  version ",xAct`xTerior`$Version[[1]],", ",xAct`xTerior`$Version[[2]]];
Print["CopyRight (C) 2013, Alfonso Garcia-Parrado Gomez-Lobo and Leo C. Stein, under the General Public License."];


Off[General::shdw]
xAct`xTerior`Disclaimer[]:=Print["These are points 11 and 12 of the General Public License:\n\nBECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM `AS IS\.b4 WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\nIN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES."]
On[General::shdw]


If[xAct`xCore`Private`$LastPackage==="xAct`xTerior`",
Unset[xAct`xCore`Private`$LastPackage];
Print[xAct`xCore`Private`bars];
Print["These packages come with ABSOLUTELY NO WARRANTY; for details type Disclaimer[]. This is free software, and you are welcome to redistribute it under certain conditions. See the General Public License for details."];
Print[xAct`xCore`Private`bars]]


$PrePrint=ScreenDollarIndices;


$DefInfoQ=False;


(* Definition and undefinition of a differential form (just a wrapper for DefTensor with the option GradeOfTensor\[Rule]{Wedge})*)
DefDifferentialForm::usage="DefDifferentialForm[form[inds], mani, Deg->deg] defines a tensor valued differential form of degree deg on the manifold mani";
UndefDifferentialForm::usage="UndefDifferentialForm[form] undefines the differential form form";
(* Grade of a differential form *)
Deg::usage="Deg[form] returns the grade of a differential form";
(* Exterior derivative *)
ExtDiff::usage="ExtDiff[form] computes the exterior derivative of the differential form form";
(* Exterior covariant derivative *)
ExtCovDiff::usage="ExtCovDiff[form,covd] represents the exterior covariant derivative of the differential form form with respect to the covariant derivative covd";
(* Computation of the exterior covariant derivative *)
ChangeExtCovDiff::usage="ChangeExtCovDiff[expr,cd1,cd2] expresses the exterior covariant derivative taken with respect to the connection defined by the covariant derivative cd1 in terms of the exterior covariant derivative taken with respect to the connection defined by the covariant derivative cd2";
(* Hodge dual *)
Hodge::usage="Hodge[metric][expr] is the Hodge dual of expr defined with respect to metric";
ExpandHodgeDual::usage="ExpandHodgeDual[expr,Coframe[mani],g] expands out all the Hodge duals of the exterior powers of Coframe[mani], defined with respect to the metric g. If the manifold tag mani is dropped, then all the instances of Coframe are expanded.";
(* Co-differential *)
CoDiff::usage="CoDiff[metric][form] is the co-differential of form computed with respect to metric";
(* Expansion of the co-differential *)
CoDiffToExtDiff::usage="CoDiffToExtDiff[expr] replaces all the instances of the co-differential in expr by their expansion in terms of the exterior derivative.";
(* Interior contraction *)
Int::usage="Int[v][form] is the interior contraction of form with the vector (rank 1-tensor) v";
(* Lie derivative on forms *)
Lie::usage="Lie[v][form] is the Lie derivative of form with respect to the vector (rank 1-tensor) v.";
(* Cartan formula for Lie derivatives *)
LieToExtDiff::usage="LieToExtDiff[expr] replaces the Lie derivative of all the differential forms in expr by their expansion obtained by means of the Cartan formula";
(* Put derivations into canonical order *)
SortDerivations::usage="SortDerivations[expr] brings expr into a new expression where all the derivations (exterior derivative, Lie derivative and interior contraction) are written in a canonical order. The default left-to-right order is defined by the variable $DerivationSortOrder";
$DerivationSortOrder::usage="$DerivationSortOrder is a global variable which encodes the default ordering of the three derivatives Int, LieD and ExtDiff. The default is {LieD,Int,ExtDiff}";
(* Variational derivative on forms *)
FormVarD::usage="..";
(* Canonical forms on the frame bundle *)
Coframe::usage="Coframe[mani] is the set of canonical 1-forms defined in the frame bundle arising from the manifold mani";
dx::usage="dx[mani] represents a holonomic co-frame in the manifold mani.";
(* The connection 1-form *)
ConnectionForm::usage="ConnectionForm[cd1,cd2,vbundle] represents the difference between the connection 1-forms associated to the covariant derivatives cd1 and cd2, both defined in the bundle vbundle. If vbundle is the tangent bundle of a differentiable manifold then ConnectionForm is automatically replaced by ChristoffelForm. Also ConnectionForm[cd1,vbundle] is automatically replaced by ConnectionForm[cd1,PD,vbundle]";
(* The curvature 2-form *)
CurvatureForm::usage="CurvatureForm[cd,vbundle] represents the curvature 2-form associated to the covariant derivative cd. If vbundle is the tangent bundle of a differentiable manifold then CurvatureForm is replaced by RiemannForm";
(* Connection 2-form for a connection in a frame bundle*)
ChristoffelForm::usage="ChristoffelForm[cd1,cd2] is the difference between the connection 1-forms associated to cd1 and cd2 which are both covariant derivatives in the tangent bundle of a manifold";
(* Curvature 2-form for a connection in a frame bundle *)
RiemannForm::usage="RiemannForm[cd] is the curvature 2-form associated to the covariant derivative cd which is a covariant derivative in the frame bundle of a manifold";
(* Transformation of the connection for to the connection tensor *)
ConnectionFormToTensor::usage="ConnectionFormToTensor[expr,covd,frame] transforms all instances of the connection form into the (A)Christoffel tensor which relates the covariant derivative defining the connection form and covd. The variable frame can take the value of either Coframe or dx. If the (A)Christoffel tensor does not exist it is created automatically.";
CurvatureFormToTensor::usage="CurvatureFormToTensor[expr,frame] transforms all the instances of the curvature form into the related Riemann or FRiemann tensor, inserting the corresponding frame (either Coframe or dx).";
ChangeCurvatureForm::usage="ChangeCurvatureForm[curvature,cd1,cd2] writes the curvature 2-form curvature[cd1,vbundle] in terms of the curvature 2-form curvature[cd2,vbundle]";
(* The torsion 2-form *)
TorsionForm::usage="TorsionForm[cd] represents the torsion 2-form arising from the covariant derivative cd (cd must be defined on the tangent bundle of a manifold)";
(* Cartan structure equations *)
ExpandExtDiff::usage="ExpandExtDiff[expr,covd] expands all the instances of the ExtDiff using the Cartan structure equations for the connection arising from covd. In this way it is possible to expand the exterior derivative of a co-frame, a torsion 2-form and the curvature 2-form. If covd is the Levi-Civita connection of a metric, then the exterior derivatives of that metric and its volume element are expanded too. ExpandExtDiff[expr,PD,mani] expands all instances of the exterior derivative in terms of partial derivatives defined in the manifold mani.";
(* Alfonso: I would call this ZeroDegreeFormQ *)
ZeroFormQ::usage="ZeroFormQ[expr] returns True if the degree of expr is zero";


Begin["`Private`"]


$ContextPath


DefProduct[Wedge,
AssociativeProductQ->True,
CommutativityOfProduct->"SuperCommutative",
GradedProductQ->True,
IdentityElementOfProduct->1,
ScalarsOfProduct->(SameQ[Grade[#,Wedge],0]&)
];


Deg[expr_]:=Grade[expr,Wedge];


DefDifferentialForm[form_,mani_,Deg->deg_,options___?OptionQ]:=
DefTensor[form,mani,GradeOfTensor->{Wedge->deg},options];


DefDifferentialForm[form_,mani_,sym_,Deg->deg_,options___?OptionQ]:=
DefTensor[form,mani,sym,GradeOfTensor->{Wedge->deg},options];


UndefDifferentialForm:=UndefTensor;


Protect[DefDifferentialForm,UndefDifferentialForm];


Options[DefGradedDerivation]={
PrintAs->Identity
};


GradeOfDerivation[head_[v_,rest___],prod_]:=GradeOfDerivation[head,prod]+Grade[v,prod];


DefGradedDerivation[der_,prod_?ProductQ,dergrade_:0,options:OptionsPattern[]]:=With[{head=SubHead[der]},
Module[{pa},

{pa}=OptionValue[{PrintAs}];

(* DefInertHead will take care of scalar-homogeneity and linearity *)
DefInertHead[der,
LinearQ->True,
ContractThrough->{delta},
PrintAs->pa];

(* Other properties of a derivation *)
MakeDerivation[head,der,NoPattern[der],prod,dergrade];

(* Nonatomic derivation *)
If[der=!=head,
(* additivity in the vector slot (but not homogeneity!) *)
head[0][__]:=0;
head[v_Plus][args__]:=head[#][args]&/@v;

(* Subscript vector argument for formatting *)
If[pa===Identity,pa=PrintAs[head]];
head/:MakeBoxes[head[v_][form_],StandardForm]:=xAct`xTensor`Private`interpretbox[head[v][form],RowBox[{SubscriptBox[pa,MakeBoxes[Short@v,StandardForm]],"[",MakeBoxes[form,StandardForm],"]"}]];
]
]
];


MakeDerivation[head_,derL_,derR_,prod_,dergrade_]:=With[{grade=GradeOfDerivation[derR,prod]},
(* Addition of grades in algebra *)
head/:GradeOfDerivation[head,prod]:=dergrade;
head/:Grade[derL[expr_,___],prod]:=Grade[expr,prod]+grade;
(* The (graded) Leibniz rule *)
derL[expr_prod,rest___]:=With[{sumgrades=FoldList[Plus,0,Grade[#,Wedge]&/@List@@expr]},
Sum[
(-1)^(grade * sumgrades[[i]] )
MapAt[derR[#,rest]&,expr,i],
{i,1,Length[expr]}
]
];
(* QUESTION: Agreement with a regular derivative when acting on scalar functions?? *)
derL[func_?ScalarFunctionQ[args__],rest___]:=xAct`xTensor`Private`multiD[derR[#,rest]&,func[args]];
(* Dependencies *)
If[!AtomQ[derR],
head/:DependenciesOfInertHead[derL]:=DependenciesOf[First[derR]]
]
];


DefGradedDerivation[ExtDiff,Wedge,+1,PrintAs->"d"];


ExtDiff[x_?ConstantQ,rest___]:=0;


(* This produces expanded expressions and is much faster when there are many scalars *)
ExtDiff[expr_Times,rest___]:=Module[{grades=Grade[#,Wedge]&/@List@@expr,pos,scalar,form},
pos=Position[grades,_?(#=!=0&),1,Heads->False];
Which[
Length[pos]>1,
	Throw[Message[ExtDiff::error1,"Found Times product of nonscalar forms: ",expr]],
Length[pos]===1,
	pos=pos[[1,1]];
	scalar=Delete[expr,{pos}];
	form=expr[[pos]];
	scalar ExtDiff[form,rest]+diff0[scalar,form],
Length[pos]===0,
	diff0[expr]
]
];
diff0[expr_Times]:=Sum[MapAt[ExtDiff,expr,i],{i,1,Length[expr]}];
diff0[expr_Times,form_]:=Sum[MapAt[ExtDiff[#,form]&,expr,i],{i,1,Length[expr]}];
diff0[expr_,form_]:=Wedge[ExtDiff[expr],form];
diff0[expr_]:=ExtDiff[expr];


ExtDiff[expr_,rest_]:=ExtDiff[expr]\[Wedge]rest;


ExtDiff[ExtDiff[expr_]]:=0


ExtDiff/:basis_Basis ExtDiff[expr_]:=ExtDiff[ContractBasis[basis expr,AIndex]];


xTensorQ@Coframe[mani_?ManifoldQ]^=True;
SlotsOfTensor[Coframe[mani_?ManifoldQ]]^:={Tangent@mani};
Coframe/:GradeOfTensor[Coframe[mani_?ManifoldQ],Wedge]=1;
SymmetryGroupOfTensor[Coframe[mani_?ManifoldQ]]^=StrongGenSet[{},GenSet[]];
DefInfo[Coframe[mani_?ManifoldQ]]^={"General co-frame",""};
DependenciesOfTensor[Coframe[mani_?ManifoldQ]]^:={mani};
HostsOf[Coframe[mani_?ManifoldQ]]^={};
TensorID[Coframe[mani_?ManifoldQ]]^={};
PrintAs[Coframe[mani_?ManifoldQ]]^="\[Theta]";


xTensorQ@dx[mani_?ManifoldQ]^=True;
SlotsOfTensor[dx[mani_?ManifoldQ]]^:={Tangent@mani};
dx/:GradeOfTensor[dx[mani_?ManifoldQ],Wedge]=1;
SymmetryGroupOfTensor[dx[mani_?ManifoldQ]]^=StrongGenSet[{},GenSet[]];
DefInfo[dx[mani_?ManifoldQ]]^={"General co-frame",""};
DependenciesOfTensor[dx[mani_?ManifoldQ]]^:={mani};
HostsOf[dx[mani_?ManifoldQ]]^={};
TensorID[dx[mani_?ManifoldQ]]^={};
PrintAs[dx[mani_?ManifoldQ]]^="dx";


ExtDiff[dx[mani_?ManifoldQ][ind_]]:=0;


DefInertHead[Hodge[metric_],
LinearQ->True,
ContractThrough->{delta},
PrintAs->Hold["\!\(\*SubscriptBox[\(*\), \("<>PrintAs[metric]<>"\)]\)"]
]


Hodge[metric_][x_ y_]:=x Hodge[metric][y]/;Grade[x,Wedge]===0


DimOfMetric[metric_]:=DimOfVBundle[VBundleOfMetric[metric]]


Hodge/:Grade[Hodge[metric_][expr_],Wedge]:=DimOfMetric[metric]-Grade[expr,Wedge]


Hodge[metric_]@Hodge[metric_][expr_]:=(-1)^(Grade[expr,Wedge](DimOfMetric[metric]-1)+SignatureOfMetric[metric][[2]])expr


ExpandHodgeDual[expr_,(coframe:(Coframe|dx))[mani_?ManifoldQ],met_]:=expr/.HoldPattern[Hodge[met][form:Wedge[coframe[mani][_]..]]|form:Hodge[met][coframe[mani][_]]]:>With[{dim=DimOfMetric[met],n=Length[form],inds=Sequence@@@List@@form},
With[{dummies=DummyIn/@ConstantArray[VBundleOfMetric[met],dim-n]},
1/(dim-n)!epsilon[met]@@Join[inds,ChangeIndex/@dummies]Wedge@@(coframe[mani]/@dummies)
]
];


ExpandHodgeDual[expr_,Coframe,met_]:=Fold[ExpandHodgeDual[#1,Coframe[#2],met]&,expr,$Manifolds];


ExpandHodgeDual[expr_,dx,met_]:=Fold[ExpandHodgeDual[#1,dx[#2],met]&,expr,$Manifolds];


DefInertHead[CoDiff[metric_],
LinearQ->True,
ContractThrough->delta,
PrintAs->Hold["\!\(\*SubscriptBox[\(\[Delta]\), \("<>PrintAs[metric]<>"\)]\)"]
]


CoDiff/:Grade[CoDiff[metric_][expr_,___],Wedge]:=-1+Grade[expr,Wedge]


CoDiffToExtDiff[expr_]:=expr//.CoDiff[met_][expr1_]:>(-1)^(DimOfMetric[met]Grade[expr1,Wedge]+DimOfMetric[met]+1+SignatureOfMetric[met][[2]])Hodge[met]@ExtDiff[Hodge[met]@expr1]


CoDiff[metric_]@CoDiff[metric_]@expr_:=0


DefGradedDerivation[ExtCovDiff,Wedge,+1,PrintAs->"d"];


ExtCovDiff/:MakeBoxes[ExtCovDiff[form_,PD?CovDQ],StandardForm]:=xAct`xTensor`Private`interpretbox[ExtCovDiff[form,PD],RowBox[{PrintAs[ExtDiff],"[",MakeBoxes[form,StandardForm],"]"}]];
ExtCovDiff/:MakeBoxes[ExtCovDiff[form_,cd_?CovDQ],StandardForm]:=xAct`xTensor`Private`interpretbox[ExtCovDiff[form,cd],RowBox[{SuperscriptBox[PrintAs[ExtDiff],Last@SymbolOfCovD[cd]],"[",MakeBoxes[form,StandardForm],"]"}]];


(* This produces expanded expressions and is much faster when there are many scalars *)
ExtCovDiff[expr_Times,rest___]:=Module[{grades=Grade[#,Wedge]&/@List@@expr,pos,scalar,form},
pos=Position[grades,_?(#=!=0&),1,Heads->False];
Which[
Length[pos]>1,
	Throw[Message[ExtCovDiff::error1,"Found Times product of nonscalar forms: ",expr]],
Length[pos]===1,
	pos=pos[[1,1]];
	scalar=Delete[expr,{pos}];
	form=expr[[pos]];
	scalar ExtCovDiff[form,rest]+extcovdiff0[scalar,form],
Length[pos]===0,
	extcovdiff0[expr]
]
];
extcovdiff0[expr_Times]:=Sum[MapAt[ExtDiff,expr,i],{i,1,Length[expr]}];
extcovdiff0[expr_Times,form_]:=Sum[MapAt[ExtDiff[#,form]&,expr,i],{i,1,Length[expr]}];
extcovdiff0[expr_,form_]:=Wedge[ExtDiff[expr],form];
extcovdiff0[expr_]:=ExtDiff[expr];


ExtCovDiff[expr_]:=ExtCovDiff[expr,PD]


xTensorQ[ConnectionForm[_,_]]^=True;
SlotsOfTensor[ConnectionForm[_,vb_?VBundleQ]]^:={vb,-vb};
ConnectionForm/:GradeOfTensor[ConnectionForm[_,_],Wedge]=1;
SymmetryGroupOfTensor[ConnectionForm[_,_]]^=StrongGenSet[{},GenSet[]];

Dagger[ConnectionForm[cd1_,vb_]]^:=ConnectionForm[cd1,Dagger@vb];
DefInfo[ConnectionForm[_,_]]^={"nonsymmetric Connection 1-form",""};
DependenciesOfTensor[ConnectionForm[cd1_,_]]^:=Union@@DependenciesOfCovD/@{cd1};
HostsOf[ConnectionForm[cd1_,vb_]]^:=Union@@HostsOf/@{cd1,vb};(* Should we put Union@@HostsOf/@{cd1,vb} here? I think so *)
TensorID[ConnectionForm[_,_]]^={};

PrintAs[ConnectionForm]^="A";
PrintAs[ConnectionForm[cd1_,_]]^:=PrintAs[ConnectionForm]<>"["<>Last@SymbolOfCovD[cd1]<>"]";
PrintAs[ConnectionForm[PD,_]]^:=PrintAs[ConnectionForm];


xTensorQ[ChristoffelForm[_]]^=True;
SlotsOfTensor[ChristoffelForm[cd1_?CovDQ]]^:={Tangent@ManifoldOfCovD@cd1,-Tangent@ManifoldOfCovD@cd1};
ChristoffelForm/:GradeOfTensor[ChristoffelForm[_],Wedge]=1;
SymmetryGroupOfTensor[ChristoffelForm[_]]^=StrongGenSet[{},GenSet[]];

Dagger[ChristoffelForm[cd1_]]^:=ChristoffelForm[cd1];
DefInfo[ChristoffelForm[_]]^={"nonsymmetric frame bundle Connection 1-form",""};
DependenciesOfTensor[ChristoffelForm[cd1_]]^:=Union@@DependenciesOfCovD/@{cd1};
HostsOf[ChristoffelForm[cd1_]]^:=Union@@HostsOf/@{cd1};(* Should we put Union@@HostsOf/@{cd1,cd2,vb} here? I think so *)
TensorID[ChristoffelForm[_]]^={};

PrintAs[ChristoffelForm]^="\[CapitalGamma]";
PrintAs[ChristoffelForm[cd1_]]^:=PrintAs[ChristoffelForm]<>"["<>Last@SymbolOfCovD[cd1]<>"]";
PrintAs[ChristoffelForm[PD]]^:=PrintAs[ChristoffelForm];


ConnectionForm[cd1_,vb_]:=ChristoffelForm[cd1]/;(Tangent@ManifoldOfCovD@cd1==vb);
ChristoffelForm[cd_,tangentbundle_]:=ChristoffelForm[cd];


ConnectionForm[PD,vb_]:=Zero;
ChristoffelForm[PD]:=Zero;


ConnectionFormToTensor[expr_,covd_,frame:(Coframe|dx)]:=expr/.{ChristoffelForm[cd1_][inds__]:>Module[{a=DummyIn@First@VBundlesOfCovD@covd},
If[xTensorQ@GiveSymbol[Christoffel,cd1,covd]===False,DefTensor[GiveSymbol[Christoffel,cd1,covd][inds,-a],ManifoldOfCovD@covd]];
GiveSymbol[Christoffel,cd1,covd][inds,-a]frame[ManifoldOfCovD@covd][a]]/;covd=!=PD,ConnectionForm[cd1_,vbundle_][inds__]:>Module[{a=DummyIn@Tangent@BaseOfVBundle@vbundle},If[xTensorQ@GiveSymbol[AChristoffel,covd,cd1]===False,DefTensor[GiveSymbol[AChristoffel,covd,cd1][inds,-a],BaseOfVBundle@vbundle]];
GiveSymbol[AChristoffel,covd,cd1][inds,-a]frame[BaseOfVBundle@vbundle][a]]/;covd=!=PD};


ConnectionFormToTensor[expr_,PD,frame:(Coframe|dx)]:=expr/.{ChristoffelForm[cd1_][inds__]:>Module[{a=DummyIn@First@VBundlesOfCovD@cd1},
GiveSymbol[Christoffel,cd1][inds,-a]frame[ManifoldOfCovD@cd1][a]],ConnectionForm[cd1__][inds__]:>Module[{a=DummyIn@First@VBundlesOfCovD@cd1},
GiveSymbol[AChristoffel,cd1][inds,-a]frame[ManifoldOfCovD@cd1][a]]}


xTensorQ[CurvatureForm[_,_]]^=True;
SlotsOfTensor[CurvatureForm[_,vb_?VBundleQ]]^:={vb,-vb};
CurvatureForm/:GradeOfTensor[CurvatureForm[_,_],Wedge]=2;
SymmetryGroupOfTensor[CurvatureForm[_,_]]^=StrongGenSet[{},GenSet[]];

Dagger[CurvatureForm[cd_,vb_]]^:=CurvatureForm[cd,Dagger@vb];
DefInfo[CurvatureForm[_,_]]^={"Curvature 2-form",""};
DependenciesOfTensor[CurvatureForm[cd_,_]]^:=DependenciesOfCovD[cd];
HostsOf[CurvatureForm[cd_,vb_]]^:=Union@@HostsOf/@{cd,vb};(* Should we put Union@@HostsOf/@{cd,vb} here? Yes*)
TensorID[CurvatureForm[_,_]]^={};

PrintAs[CurvatureForm]^="F";
PrintAs[CurvatureForm[cd_,_]]^:=PrintAs[CurvatureForm]<>"["<>Last@SymbolOfCovD[cd]<>"]";


xTensorQ[RiemannForm[_]]^=True;
SlotsOfTensor[RiemannForm[cd_?CovDQ]]^:={Tangent@ManifoldOfCovD@cd,-Tangent@ManifoldOfCovD@cd};
RiemannForm/:GradeOfTensor[RiemannForm[_],Wedge]=2;
SymmetryGroupOfTensor[RiemannForm[_]]^=StrongGenSet[{},GenSet[]];

Dagger[RiemannForm[cd_]]^:=RiemannForm[cd];
DefInfo[RiemannForm[_]]^={"Curvature 2-form in the frame bundle",""};
DependenciesOfTensor[RiemannForm[cd_]]^:=DependenciesOfCovD[cd];
HostsOf[RiemannForm[cd_]]^:=Union@@HostsOf/@{cd};(* Should we put Union@@HostsOf/@{cd,vb} here? Yes*)
TensorID[RiemannForm[_]]^={};

PrintAs[RiemannForm]^="R";
PrintAs[RiemannForm[cd_]]^:=PrintAs[RiemannForm]<>"["<>Last@SymbolOfCovD[cd]<>"]";


CurvatureForm[cd_?CovDQ,vbundle_]:=RiemannForm[cd]/;vbundle===Tangent@ManifoldOfCovD@cd;
RiemannForm[cd_,vbundle_]:=RiemannForm[cd];


CurvatureFormToTensor[expr_,frame:(Coframe|dx)]:=expr/.{HoldPattern@CurvatureForm[cd1_,vbundle1_?VBundleQ][inds__]:>Module[{a=DummyIn@First@VBundlesOfCovD@cd1,b=DummyIn@First@VBundlesOfCovD@cd1},
1/2GiveSymbol[FRiemann,cd1][-a,-b,Sequence@@Reverse@List@inds]Wedge[frame[ManifoldOfCovD@cd1][a],frame[ManifoldOfCovD@cd1][b]]],RiemannForm[cd1_][inds__]:>Module[{a=DummyIn@First@VBundlesOfCovD@cd1,b=DummyIn@First@VBundlesOfCovD@cd1},
-$RiemannSign 1/2GiveSymbol[Riemann,cd1][-a,-b,Sequence@@Reverse@List@inds]Wedge[frame[ManifoldOfCovD@cd1][a],frame[ManifoldOfCovD@cd1][b]]]}


xTensorQ[TorsionForm[_]]^=True;
SlotsOfTensor[TorsionForm[cd_]]^:={Tangent@ManifoldOfCovD@cd};
TorsionForm/:GradeOfTensor[TorsionForm[_],Wedge]=2;
SymmetryGroupOfTensor[TorsionForm[_]]^=StrongGenSet[{},GenSet[]];

Dagger[TorsionForm[cd_]]^:=TorsionForm[cd]
DefInfo[TorsionForm[_]]^={"Torsion 2-form",""};
DependenciesOfTensor[TorsionForm[cd_]]^:=DependenciesOfCovD[cd];
HostsOf[TorsionForm[cd_]]^:=HostsOf@cd;(* Should we put HostsOf@cd here? OK*)
TensorID[TorsionForm[_]]^={};


PrintAs[TorsionForm]^="\[GothicCapitalT]";
PrintAs[TorsionForm[cd_]]^:=PrintAs[TorsionForm]<>"["<>Last@SymbolOfCovD[cd]<>"]";


ConnectionForm[cd1_,cd2_,vbundle_][inds__]:=ConnectionForm[cd1,vbundle][inds]-ConnectionForm[cd2,vbundle][inds];


ChangeExtCovDiff[expr_,cd_?CovDQ,cd_]:=expr;
ChangeExtCovDiff[expr_,cd1_?CovDQ,cd2_:PD]:=expr/.HoldPattern[ExtCovDiff[expr1_,cd1]]:>
makeChangeExtD[ChangeExtCovDiff[expr1,cd1,cd2],cd1,cd2];

ChangeExtCovDiff[expr_,list_List,covd2_:PD]:=Fold[ChangeExtCovDiff[#1,#2,covd2]&,expr,list];
ChangeExtCovDiff[expr_,x_,_:PD]:=Throw@Message[ChangeExtD::unknown,"covariant derivative",x];
ChangeExtCovDiff[expr_]:=ChangeExtCovDiff[expr,$CovDs];


makeChangeExtD[expr_,cd1_,cd2_]:=With[{vbs=Apply[Union,VBundlesOfCovD/@DeleteCases[{cd1,cd2},PD]]},
ExtCovDiff[expr,cd2]+Plus@@Map[addAChr1[expr,cd1,cd2],xAct`xTensor`Private`selecton[Select[FindFreeIndices@expr,AIndexQ],vbs]]//ReduceAChr1
];


addAChr1[expr_,cd1_,cd2_][{oldind_?xAct`xTensor`Private`upQ,dummy_}]:=Wedge[ConnectionForm[cd1,cd2,VBundleOfIndex@oldind][oldind,-dummy],ReplaceIndex[expr,oldind->dummy]]
addAChr1[expr_,cd1_,cd2_][{oldind_?xAct`xTensor`Private`downQ,dummy_}]:=-Wedge[ConnectionForm[cd1,cd2,VBundleOfIndex@oldind][dummy,oldind],ReplaceIndex[expr,oldind->-dummy]]


ReduceAChr1[expr_]:=expr//.{ConnectionForm[cd1_,cd2_,vb_][a_,b_]:>ConnectionForm[cd1,PD,vb][a,b]/;(cd2=!=PD&&FreeQ[VBundlesOfCovD@cd2,vb]),
ConnectionForm[cd1_,cd2_,vb_][a_,b_]:>ConnectionForm[PD,cd2,vb][a,b]/;(cd1=!=PD&&FreeQ[VBundlesOfCovD@cd1,vb])}


ExtCovDiff[ExtCovDiff[expr_,PD],PD]:=0


ExtCovDiff[ExtCovDiff[expr_,cd_],cd_]:=
Plus@@Map[addFRiem2[expr,cd],xAct`xTensor`Private`selecton[Select[FindFreeIndices@expr,AIndexQ],VBundlesOfCovD@cd]];


addFRiem2[expr_,cd_][{oldind_?xAct`xTensor`Private`upQ,dummy_}]:=Wedge[CurvatureForm[cd,VBundleOfIndex[oldind]][oldind,-dummy],ReplaceIndex[expr,oldind->dummy]];

addFRiem2[expr_,cd_][{oldind_?xAct`xTensor`Private`downQ,dummy_}]:=-Wedge[CurvatureForm[cd,VBundleOfIndex[oldind]][dummy,oldind],ReplaceIndex[expr,oldind->-dummy]]


CurvatureForm[PD,_]:=Zero;


RiemannForm[PD]:=Zero;


ChangeCurvatureForm[expr_,cd_,cd_]:=expr;
ChangeCurvatureForm[expr_,cd1_?CurvatureQ,cd2_:PD]:=ReduceAChr1[expr/.changeCurvatureFormRules[cd1,cd2]];
ChangeCurvatureForm[expr_,list_List,cd2_:PD]:=Fold[ChangeCurvatureForm[#1,#2,cd2]&,expr,list];
ChangeCurvatureForm[expr_,_,_:PD]:=expr;
ChangeCurvatureForm[expr_]:=ChangeCurvatureForm[expr,$CovDs];


changeCurvatureFormRules[cd2_,cd1_]:={CurvatureForm[cd2,vb_?VBundleQ][a_,b_]:>
With[{c=DummyIn@vb,A1=ConnectionForm[cd2,cd1,vb]},CurvatureForm[cd1,vb][a,b]+ExtCovDiff[A1[a,b],cd1]+Wedge[A1[a,-c],A1[c,b]]],RiemannForm[cd2][a_,b_]:>
With[{c=DummyIn@Tangent@ManifoldOfCovD@cd2,A1=ChristoffelForm[cd2,cd1]},RiemannForm[cd1][a,b]+ExtCovDiff[A1[a,b],cd1]+Wedge[A1[a,-c],A1[c,b]]]};


ExtDiff[expr_,cd_?CovDQ]:=ExtDiff[expr];


(* Exterior derivative when covd is PD *)
ExpandExtDiff[expr_,PD,mani_?ManifoldQ]:=(expr/.ExtDiff@expr1_:>Module[{a=DummyIn@Tangent@mani},dx[mani][a]PD[-a]@expr1 ]/;Deg@expr1===0);


ExpandExtDiff[expr_,covd_]:=(expr/.
(* Exterior derivative of the coframe *)
{HoldPattern[ExtDiff@Coframe[mani_][ind_]]:>Module[{a=DummyIn@VBundleOfIndex@ind},If[ManifoldOfCovD@covd===mani,-ConnectionForm[covd,VBundleOfIndex@ind][ind,-a]\[Wedge]Coframe[mani][a]+TorsionForm[covd][ind],-ConnectionForm[covd,VBundleOfIndex@ind][ind,-a]\[Wedge]Coframe[mani][a]]],
(* Exterior derivative of the connection *)
HoldPattern[ExtDiff[(connection:(ConnectionForm|ChristoffelForm))[covd,vbundle_:Tangent@ManifoldOfCovD@covd][a1_,-a2_]]]:>Module[{a=DummyIn@VBundleOfIndex@a1},CurvatureForm[covd,vbundle][a1,-a2]-connection[covd,vbundle][a1,-a]\[Wedge]connection[covd,vbundle][a,-a2]],
(* Exterior derivative of the torsion *)
HoldPattern[ExtDiff@TorsionForm[covd][ind_]]:>Module[{a=DummyIn@VBundleOfIndex@ind},Coframe[ManifoldOfCovD@covd][a]\[Wedge]RiemannForm[covd][ind,-a]-ChristoffelForm[covd][ind,-a]\[Wedge]TorsionForm[covd][a]],
(* Exterior derivative of the curvature *)
HoldPattern[ExtDiff[(curvature:(CurvatureForm|RiemannForm))[covd,vbundle_:Tangent@ManifoldOfCovD@covd][a1_,-a2_]]]:>Module[{a=DummyIn@VBundleOfIndex@a1},ConnectionForm[covd,vbundle][a,-a2]\[Wedge]curvature[covd,vbundle][a1,-a]-curvature[covd,vbundle][a,-a2]\[Wedge]ConnectionForm[covd,vbundle][a1,-a]],
(* Exterior derivative of the metric (indices downstairs) *)
HoldPattern[ExtDiff[metr_?MetricQ[-a1_,-a2_]]]:>Module[{a=DummyIn@VBundleOfIndex@a1},ChristoffelForm[covd][a,-a1]MetricOfCovD[covd][-a,-a2]+ChristoffelForm[covd][a,-a2]MetricOfCovD[covd][-a,-a1]]/;MetricOfCovD[covd]===metr,
(* Exterior derivative of the metric (indices upstairs) *)
HoldPattern[ExtDiff[metr_?MetricQ[a1_Symbol,a2_Symbol]]]:>-ChristoffelForm[covd][a1,a2]-ChristoffelForm[covd][a2,a1]/;MetricOfCovD[covd]===metr,
(* Exterior derivative of the tensor form of volume element, regarded as a zero-form (indices downstairs). I think that this formula is dimension independent *)
If[MetricOfCovD[covd]=!=Null,ExtDiff[epsilon[MetricOfCovD[covd]][inds__?DownIndexQ]]:>Module[{a=DummyIn@VBundleOfMetric@MetricOfCovD[covd]},ChristoffelForm[covd][a,-a]epsilon[MetricOfCovD[covd]][inds]],HoldPattern[ExtDiff[epsilon[MetricOfCovD[covd]][inds__]]]:>ExtDiff[epsilon[MetricOfCovD[covd]][inds]]],
(* Exterior derivative when covd is the parallel derivative of a coordinate chart *)
HoldPattern@ExtDiff@expr1_?ScalarQ:>Inner[covd[{#1,-BasisOfCovD@covd}]@expr1 ExtDiff@#2&,CNumbersOf[BasisOfCovD@covd,VBundleOfBasis@BasisOfCovD@covd],ScalarsOfChart@BasisOfCovD@covd,Plus]/;(Deg@expr1===0&&BasisOfCovD@covd=!=Null)});


DefGradedDerivation[Int[v_],Wedge,-1,PrintAs->"\[Iota]"];


Int[v_][f_?ZeroFormQ]:=0;
Int[v_][f_?ZeroFormQ form_]:=f Int[v][form];
Int[f_?ScalarQ v_][form_]:=f Int[v][form];


DefGradedDerivation[Lie[v_],Wedge,0,PrintAs->"\[ScriptCapitalL]"];


Lie[f_?ScalarQ v_][form_]:=f Lie[v]@form+Wedge[ExtDiff@f,Int[v]@form];


LieToExtDiff[expr_]:=expr/.{Lie[v_][form_]:>ExtDiff@Int[v]@form+Int[v]@ExtDiff@form};


SortDerivationsRule[ExtDiff,ExtDiff]={};


SortDerivationsRule[Int,Int]={
HoldPattern[Int[v_]@Int[w_]@form_]:>-Int[w]@Int[v]@form/;!OrderedQ[{v,w}]
};


SortDerivationsRule[Lie,Lie]={
HoldPattern[Lie[v_]@Lie[w_]@form_]:>Module[{a=First@FindFreeIndices[v]},Lie[w]@Lie[v]@form+Lie[Bracket[v,w][a]]@form]/;!OrderedQ[{v,w}]
};


SortDerivationsRule[Int,Lie]={
HoldPattern[Lie[w_]@Int[v_]@form_]:>Module[{a=First@FindFreeIndices[w]},Int[v]@Lie[w]@form+Int[Bracket[w,v][a]]@form]
};
SortDerivationsRule[Lie,Int]={
HoldPattern[Int[v_]@Lie[w_]@form_]:>Module[{a=First@FindFreeIndices[w]},Lie[w]@Int[v]@form+Int[Bracket[v,w][a]]@form]
};


SortDerivationsRule[Int,ExtDiff]={
HoldPattern[ExtDiff[Int[v_]@form_]]:>-Int[v]@ExtDiff@form+Lie[v]@form
};
SortDerivationsRule[ExtDiff,Int]={
HoldPattern[Int[v_]@ExtDiff[form_]]:>-ExtDiff@Int[v]@form+Lie[v]@form
};


SortDerivationsRule[Lie,ExtDiff]={
HoldPattern[ExtDiff[Lie[v_]@form_]]:>Lie[v]@ExtDiff@form
};
SortDerivationsRule[ExtDiff,Lie]={
HoldPattern[Lie[v_]@ExtDiff[form_]]:>ExtDiff@Lie[v]@form
};


$Derivations={Lie,Int,ExtDiff};
$DerivationSortOrder=$Derivations;


SortDerivations[expr_]:=SortDerivations[expr,$DerivationSortOrder]
SortDerivations[expr_,order_List]:=Module[{},

(* Make sure that order is some permutation of $Derivations *)
If[Sort@order=!=Sort@$Derivations,Throw@Message[SortDerivations::invalid,"order",order];];

expr//.Join@@Table[Join@@(SortDerivationsRule[order[[i]],#]&/@Drop[order,i]),{i,1,Length@order-1}]//.Join@@(SortDerivationsRule[#,#]&/@order)
];


TopRankQ[form_]:=With[{manifolds=Select[DependenciesOf@form,ManifoldQ]},
If[Length@manifolds != 1,
Throw@Message[TopRankQ::error1,"Forms must have exactly 1 manifold in dependencies."],
TopRankQ[form,First@manifolds]]];
TopRankQ[form_,mani_?ManifoldQ]:=Grade[form,Wedge]===DimOfManifold@mani;


InvHodge[metric_][expr_]:=With[{k=Grade[expr,Wedge],n=DimOfMetric@metric,s=SignDetOfMetric@metric},
(-1)^(k(n-k))s Hodge[metric]@expr];


(* TODO:More checks that form is actually on same manifold as metric, etc. *)
(* Generate rest. Replace dummies in expr. This does not act on scalar arguments of functions *)
FormVarD[form_,met_][expr_]:=If[TopRankQ[expr]&&ScalarQ[expr],
FormVarD[form,met][ReplaceDummies@expr,1],
Throw@Message[General::error1,"Can only take variational derivative of top-rank form."]];
(* Thread over Plus *)
FormVarD[form_,met_][expr_Plus,rest_]:=FormVarD[form,met][#,rest]&/@expr;
FormVarD[form_,met_][expr_SeriesData,rest_]:=xAct`xTensor`Private`SeriesDataMap[FormVarD[form,met][#,rest]&,expr];
(* FormVarD on products: sum of VarDtake's of elements *)
FormVarD[form_,met_][expr_Times,rest_]:=With[{grades=Grade[#,Wedge]&/@List@@expr},
If[Length@Position[grades,_?(#=!=0&),1,Heads->False]>1,
Throw[Message[FormVarD::error1,"Found Times product of nonscalar forms: ",expr]]];	Sum[FormVarDtake[form,met,rest,List@@expr,count],{count,Length@expr}]
];
(* FormVarD on wedges: sum of FormVarDtake's of elements.
Note the use of sumgrades for reordering the Wedge, as described above. *)
FormVarD[form_,met_][expr_Wedge,rest_]:=With[{grades=Grade[#,Wedge]&/@List@@expr},
With[{sumgrades=FoldList[Plus,0,grades]},
Sum[(-1)^(grades[[count]]* sumgrades[[count]])FormVarDtake[form,met,rest,List@@expr,count],{count,Length@expr}]]];
(* FormVarD element n of a list of Wedge factors (no sign--it was included above) *)
FormVarDtake[form_,met_,rest_,list_List,n_Integer]:=FormVarD[form,met][list[[n]],Wedge[Wedge@@Drop[list,{n}],rest]];
(* Scalar functions. Multiargument generalization contributed by Leo. multiD is not enough here.
 Since operating on a scalar function, don't need extra Wedge's *)
FormVarD[form_,met_][func_?ScalarFunctionQ[args__],rest_]:=With[{repargs=ReplaceDummies/@{args}},Plus@@MapThread[FormVarD[form,met][#1,rest (Derivative@@#2)@func@@repargs]&,{repargs,IdentityMatrix@Length@repargs}]];
(* Remove Scalar head because in general the result is not a scalar *)
FormVarD[form_,met_][Scalar[expr_],rest_]:=FormVarD[form,met][ReplaceDummies[expr],rest];
(* Constants *)
FormVarD[_,_][x_?ConstantQ,_]:=0;
(* Same tensor: metric. Do not use ContractMetric, which hides the metric.
Note: This part is identical to the code in VarD, since it's only metric being Wedged with rest. *)
FormVarD[metric_[a_,b_],met_][metric_Symbol?MetricQ[c_,d_],rest_]:=xAct`xTensor`Private`metricsign[a,b,c,d]ToCanonical[rest (metric[ChangeIndex@a,c]metric[ChangeIndex@b,d]+metric[ChangeIndex@a,d]metric[ChangeIndex@b,c])/2,UseMetricOnVBundle->None];
(* Same tensor. Place indices in proper delta positions. QUESTION: could this be problematic for spinors?
Note: This part is identical to the code in VarD, since it's only deltas being Wedged with rest. *)
FormVarD[form_[inds1___],met_][form_?xTensorQ[inds2___],rest_]:=With[{clist=ChangeIndex/@IndexList[inds1]},
ToCanonical[ImposeSymmetry[Inner[xAct`xTensor`Private`varddelta,clist,IndexList[inds2],Times],clist,SymmetryGroupOfTensor[form[inds1]]]rest,UseMetricOnVBundle->None]];
(* A different tensor *)
FormVarD[form1_[inds1___],met_][form2_?xTensorQ[inds2___],rest_]:=0/;!ImplicitTensorDepQ[form2,form1];
(* Hodge identity *)
FormVarD[form_,met_][Hodge[met_][expr_],rest_]:=With[{k=Grade[expr,Wedge],n=DimOfMetric@met},
(-1)^(k(n-k))FormVarD[form,met][expr,Hodge[met]@rest]];
(* diff \[Rule] Replaced by ExtDiff to adjust to the new notation. Dropped cd *)
FormVarD[form_,met_][ExtDiff[expr_],rest_]:=FormVarD[form,met][expr,Hodge[met]@CoDiff[met][InvHodge[met]@rest]];
(* codiff \[Rule] Replaced by CoDiff to adjust to the new notation. Dropped cd and replaced ExtCovDiff by ExtDiff *)
FormVarD[form_,met_][CoDiff[met_][expr_],rest_]:=FormVarD[form,met][expr,Hodge[met]@ExtDiff[InvHodge[met]@rest]];


End[];
EndPackage[];
